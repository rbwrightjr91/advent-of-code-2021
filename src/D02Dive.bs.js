// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Process = require("process");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Js_option = require("rescript/lib/js/js_option.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var CamlinternalLazy = require("rescript/lib/js/camlinternalLazy.js");

var readInput = {
  LAZY_DONE: false,
  VAL: (function () {
      return Fs.readFileSync(Caml_array.get(Process.argv, 2), "utf8").trim().split("\n");
    })
};

function parseCommands(param) {
  return CamlinternalLazy.force(readInput).map(function (e) {
              var el = e.split(" ");
              var n = Belt_Int.fromString(Caml_array.get(el, 1));
              return [
                      Caml_array.get(el, 0),
                      n !== undefined ? n : -1
                    ];
            });
}

function partOne(param) {
  console.log("Day 02 - Part 1\n================");
  var arr = parseCommands(undefined);
  var tuple = arr.reduce((function (acc, command) {
          var distance = command[1];
          var match = Js_option.some(command[0]);
          if (match !== undefined) {
            switch (match) {
              case "down" :
                  return [
                          acc[0] + distance | 0,
                          acc[1]
                        ];
              case "forward" :
                  return [
                          acc[0],
                          acc[1] + distance | 0
                        ];
              case "up" :
                  return [
                          acc[0] - distance | 0,
                          acc[1]
                        ];
              default:
                console.log("Invalid direction");
                return acc;
            }
          } else {
            console.log("Invalid direction");
            return acc;
          }
        }), [
        0,
        0
      ]);
  console.log(Math.imul(tuple[0], tuple[1]));
  console.log("================\n");
  
}

function partTwo(param) {
  console.log("Day 02 - Part 2\n================");
  var arr = parseCommands(undefined);
  var tuple = arr.reduce((function (acc, command) {
          var distance = command[1];
          var match = Js_option.some(command[0]);
          if (match !== undefined) {
            switch (match) {
              case "down" :
                  return [
                          acc[0],
                          acc[1],
                          acc[2] + distance | 0
                        ];
              case "forward" :
                  var aim = acc[2];
                  return [
                          acc[0] + Math.imul(aim, distance) | 0,
                          acc[1] + distance | 0,
                          aim
                        ];
              case "up" :
                  return [
                          acc[0],
                          acc[1],
                          acc[2] - distance | 0
                        ];
              default:
                console.log("Invalid");
                return acc;
            }
          } else {
            console.log("Invalid");
            return acc;
          }
        }), [
        0,
        0,
        0
      ]);
  console.log(Math.imul(tuple[0], tuple[1]));
  console.log("================\n");
  
}

partOne(undefined);

partTwo(undefined);

exports.readInput = readInput;
exports.parseCommands = parseCommands;
exports.partOne = partOne;
exports.partTwo = partTwo;
/*  Not a pure module */
